PHP - Introducción
=========================
[INDICE](https://github.com/HecFranco/Apuntes/blob/master/PHP/00.Indice.md)
---------------------------------------------------------------------------
9. [PROGRAMACIÓN ORIENTADA A OBJETOS]()

----------------------------------

9.PROGRAMACIÓN ORIENTADA A OBJETOS
==================================

**[Regresar al índice](#indice)**

----------------------------------

9.1.Clases
----------
*Las clases son para POO lo que para los arquitectos son los planos.*
Para definir una clase usamos la palabra reservada `class`. Las clases tienen propiedades, atributos, variables internas y funciones o métodos.

| Producto.php  |
|---------------|
```php
class Producto {
    // Declaración de propiedades
   var $nombre;
   var $talla;
   var $precio;
}
```

**[Regresar al índice](#indice)**

----------------------------------

9.2.Instancias
--------------
Las instancias permiten crear objetos a partir de las clases ya generadas. Para crear la instancia generamos una nuev variable que mediante la palabra reservada `new` instanciará la clase creando un nuevo objeto con ese patrón ya generado anteriormente.

| Producto.php  |
|---------------|
```php
class Producto {
    // Declaración de propiedades
   var $nombre;
   var $talla;
   var $precio;
}
```

| instancia.php  |
|----------------|
```php
<?php
require_once 'Producto.php';
// Crea una nueva instancia de Producto
$producto = new Producto;

// Setea las propiedades
$producto->nombre = 'Camiseta de CSS';
$producto->talla = 'L';
$producto->precio = 12;

// Acceder a las propiedades
echo "Acceder a las propiedades";
echo $producto->nombre." ";
echo $producto->talla." ";
echo $producto->precio." ";
echo "<br>";
```
**Nota:** se puede instanciar la clase mediante `new`, y setearla o darle valores referenciándolas mediante el operador flecha `->`, como se puede ver en el siguiente ejemplo `$producto->nombre`. Así mismo podremos referenciar dicha propiedad usando también el operadorflecha `->`, de la siguiente manera: `echo $producto->precio." ";`.

**Ejemplo**

| Producto.php  |
|---------------|
```php
class Producto {

    // Declaración de propiedades
    public $nombre;
    public $talla;
    public $precio = 12;

    function __construct($nombre, $talla)
    {
        //echo "He sido construido.n";
        $this->nombre = $nombre;
        $this->talla = $talla;
    }

    function resumen()
    {
        echo $this->nombre." ";
        echo $this->talla." ";
        echo $this->precio." ";
    }
}
```

| instancia.php  |
|----------------|
```php
require_once 'Producto.php';
// Crea una nueva instancia de Producto
$producto = new Producto;

// Setea las propiedades
$producto->nombre = 'Camiseta de CSS';
$producto->talla = 'L';
$producto->precio = 12;

// Acceder a las propiedades
echo "Acceder a las propiedades";
echo $producto->nombre." ";
echo $producto->talla." ";
echo $producto->precio." ";
echo "<br>";

// Crea otra instancia de Producto
echo "Crea otra instancia de Producto";
$producto2 = new Producto;

$producto2->nombre = 'Camiseta de JS';
$producto2->talla = 'S';
$producto2->precio = 11;

echo "Otro producto: {$producto2->nombre}<br>";
echo "El precio de {$producto->nombre} es {$producto->precio}<br>";
echo "El precio de {$producto2->nombre} es {$producto2->precio}<br>";
$producto->resumen();
echo "<br>";
$producto2->resumen();
```

**[Regresar al índice](#indice)**

----------------------------------

9.3.Valores por defecto
-----------------------

Los valores por defecto permiten añadir a una variable declarada un valor por defecto que tendrá la misma cuando no se facilite al instanciar la clase.

| Producto.php  |
|---------------|
```php
class Producto {
    // Declaración de propiedades
   var $nombre;
   var $talla;
   var $precio=12;
}
```

**[Regresar al índice](#indice)**

----------------------------------

9.4.Constructores
-----------------
Los constructores se encargan de resumir las acciones de inicialización de los objetos. Cuando se instancia un objeto, se tienen que realizar varios pasos en su inicialización, por ejemplo dar valores a sus atributos y eso es de lo que se encarga el constructor. Los constructores pueden recibir unos datos para inicializar los objetos como se desee en cada caso.

La sintaxis para la creación de constructor varía con respecto a la de PHP 3 y 4, pues debe llamarse con un nombre fijo: __construct(). (Son dos guiones bajos antes de la palabra "construct")

A lo largo de los ejemplos de este manual vamos a ir creando un código para gestión de un videoclub. Vamos a empezar definiendo una clase cliente, que utilizaremos luego en nuestro programa.
```php
class cliente{ 
   	public $nombre; 
   	public $numero; 
   	public $peliculas_alquiladas; 

   	function __construct($nombre,$numero){ 
      	$this->nombre=$nombre; 
      	$this->numero=$numero; 
      	$this->peliculas_alquiladas=array(); 
   	} 

   	function dame_numero(){ 
      	return $this->numero; 
   	} 
}
```
El constructor en esta clase recibe el nombre y número que asignar al cliente, que introduce luego en sus correspondientes propiedades. Además inicializa el atributo películas_alquiladas como un array, en este caso vacío porque todavía no tiene ninguna película en su poder.

----------------------------

*Nota:* En programación orientada a objetos $this hace referencia al objeto sobre el que se está ejecutando el método. En este caso, como se trata de un constructor, $this hace referencia al objeto que se está construyendo. Con $this->nombre=$nombre; estamos asignando al atributo `nombre` del objeto que se está construyendo el valor que contiene la variable $nombre, que se ha recibido por parámetro.

----------------------------

Luego hemos creado un método muy sencillo para poder utilizar el objeto. Vamos a ver unas acciones simples para ilustrar el proceso de instanciación y utilización de los objetos.
```php
//instanciamos un par de objetos cliente 
$cliente1 = new cliente("Pepe", 1); 
$cliente2 = new cliente("Roberto", 564); 

//mostramos el numero de cada cliente creado 
echo "El identificador del cliente 1 es: " . $cliente1->dame_numero(); 
echo "El identificador del cliente 2 es: " . $cliente2->dame_numero();
```
Este ejemplo obtendría esta salida como resultado de su ejecución:

El identificador del cliente 1 es: 1 
El identificador del cliente 2 es: 564

**[Regresar al índice](#indice)**

----------------------------------

| producto.php  |
|---------------|
```php
class Producto {

    // Declaración de propiedades
    public $nombre;
    public $talla;
    public $precio = 12;

    function __construct($nombre, $talla)
    {
        //echo "He sido construido.n";
        $this->nombre = $nombre;
        $this->talla = $talla;
    }

    function resumen()
    {
        echo $this->nombre." ";
        echo $this->talla." ";
        echo $this->precio." ";
    }
}
```

| constructor.php  |
|------------------|
```php
require_once 'Producto.php';

$producto1 = new Producto('Camiseta de HTML', 'L');
$producto2 = new Producto('Camiseta de JS', 'S');
$producto3 = new Producto('Camiseta de CSS', 'M');
$producto4 = new Producto('Camiseta de PHP', 'L');

echo $producto1->nombre . PHP_EOL;
echo $producto2->nombre . PHP_EOL;
echo $producto3->nombre . PHP_EOL;
echo $producto4->nombre . PHP_EOL;
```

9.5.Interfaces
--------------

Las **interfaces** de objetos son contratos que han de cumplir las **clases** que las implementan. Contienen **métodos vacíos** que obligan a una clase a emplearlos, promoviendo así un **estándar de desarrollo**.

Si una clase implementa una _**interface**_, está obligada a usar todos los métodos de la misma (y los mismos tipos de argumentos de los métodos), de lo contrario dará un **error fatal**. Pueden emplearse **más de una interface en cada clase**, y pueden **extenderse** entre ellas mediante _extends_. Una interface puede extender una o más interfaces.

Todos los métodos declarados en una interface deben ser públicos. 

Para definir una interface se utiliza la parabra _**interface**_, y para extenderla se utiliza _**implements**_. 

```
interface Automovil {
    public function getTipo();
    public function getRuedas();
}
class Coche implements Automovil {
    public function getTipo(){
        echo "Coche";
    }
    public function getRuedas(){
        echo "4";
    }
}
class Moto implements Automovil {
    public function getTipo(){
        echo "Moto";
    }
    public function getRuedas(){
        echo "2";
    }
}
```

Las clases **Coche** y **Moto** están obligadas a definir las funciones _getTipo()_ y _getRuedas()_. Así se crea un modelo para todas las **clases** de automóviles que deben aportar o definir unos métodos mínimos. Si por ejemplo _getTipo()_ tuviera un argumento de tipo _**Array**_: _getTipo(Array $tipos)_, las clases que implementen la interface deberán importar un argumento del mismo tipo.

Las interfaces también pueden definir **constantes**, que funcionan igual que las **constantes en clases**, pero no pueden ser sobreescritas por sus descendientes, ya sean clases o interfaces.

Se utilizan cuando se tienen muchas clases que tienen en común un comportamiento, pudiendo asegurar así que ciertos métodos estén disponibles en cualquiera de los objetos que queramos crear. Son especialmente importantes para la **arquitectura de aplicaciones complejas**.

**[Regresar al índice](#indice)**

----------------------------------

----------------------------------------------
----------------------------------------------

¿Cuál es la diferencia entre public, private y protected en las aplicaciones PHP? ¿Cuándo y por qué debería utilizar cada una de ellas? Ejemplos de variables y funciones de cada tipo:
```php
// Variables y funciones public
public $variable;
public function loQueSea() {
    // código ...
}
 
// Variables y funciones private
private $variable;
private function loQueSea() {
    // código ...
}
 
// Variables y funciones protected
protected $variable;
protected function loQueSea() {
    // código ...
}
```
* **public** hace que la variable/función se pueda acceder desde cualquier lugar, como por ejemplo otras clases y otras instancias de esa misma clase.
* **private** hace que la variable/función solamente se pueda utilizar desde la misma clase que las define.
* **protected** hace que la variable/función se puede acceder desde la clase que las define y también desde cualquier otra clase que herede de ella.
En otras palabras: *private = solo tú*, *protected = tú y tus descendientes*, *public = cualquiera*.
